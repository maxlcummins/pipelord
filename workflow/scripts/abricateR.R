#!/usr/bin/env Rscript
#' A function for processing abricate output.
#
#' Read the documents on the github page https://github.com/maxlcummins/abricateR for more info
#' @param abricate_in Filename of your abricate input
#' @param output_directory Prefix for object/filename of your output files
#' @param output Prefix for object/filename of your output files
#' @param identity Nucleotide identity cut-off. Default = 90
#' @param length Length/coverage cut-off. Default = 90
#' @param writecsv TRUE/FALSE: Write/Dont write to csv. Default = FALSE
#' @param pointfinder_data Defaults to a placeholding character - replace with a path to your concatenated pointfinder data.
#' @param ColV_Liu_data Defaults to a placeholding character - replace with a path to your abriate data for the Liu ColV database.
#'
#' If you want to add pointfinder data, concatenate it as follows to provide filenames for the strains. This code assumes you are in a folder with only your ${file}.tab files generated by pointfinder.
#' for f in */*.tsv; do awk 'NR == 1 {print $0 "\tname_file"; next;}{print $0 "\t" FILENAME;}' $f; done > pointfinder_results_tmp.txt
#' awk 'FNR==1 { header = $0; print } $0 != header' pointfinder_results_tmp.txt > pointfinder_results.txt
#
# Update - Jan 2021 - Made pMLST fit for IncF-S types


abricateR <-
        function(abricate_in,
                 output,
                 output_directory = ".",
                 identity = 90,
                 length = 90,
                 writecsv = TRUE,
                 pointfinder_data = "a",
                 ColV_Liu_data = "b",
                 pMLST_data = "c") {

                require(readr)
                require(magrittr)
                require(dplyr)
                require(tidyverse)
                require(purrr)
                require(data.table)

                #provides a name for downstream files based on user input
                name <- output
                #reads input file (abricate output in tab separated format.
                #Colname reassignment


                #Read in full abricate genotype data sheet
                df <- read_delim(
                        abricate_in,
                        "\t",
                        escape_double = FALSE,
                        trim_ws = TRUE,
                        col_names = TRUE
                )

                #Remove cases where there are multiple headers from concatenation of abricate reports
                df <- df %>% filter(SEQUENCE != "SEQUENCE")

                #Colname reassignment
                colnames(df)[c(1, 10:11)] <-
                        c("name", "perc_coverage", "perc_identity")
                df_colnames <- colnames(df)

                #Convert percent coverage and identity to numeric type to allow filtering
                df$perc_coverage <- as.numeric(df$perc_coverage)
                df$perc_identity <- as.numeric(df$perc_identity)

                # appends a 1 to the final column of each row (used later by dcast)
                rep(x = 1, times = nrow(df)) -> df$gene_present

                # Removes .fasta* in column sample name
                gsub(pattern = "\\.fasta.*",
                     replacement = "",
                     x = df$name) ->
                        df$name

                if (pointfinder_data != "a") {
                        #Read in pointfinder data on resistance snps
                        res_snps <- read_delim(
                                pointfinder_data,
                                "\t",
                                escape_double = FALSE,
                                trim_ws = TRUE
                        )

                        #fix colnames of res_snps for consistency
                        colnames(res_snps) <-
                                gsub("name_file", "name", colnames(res_snps))

                        #fix colnames of res_snps for consistency
                        colnames(res_snps) <-
                                gsub("Mutation", "GENE", colnames(res_snps))

                        #fix colnames of res_snps for consistency
                        res_snps$GENE <-
                                gsub("^", "pointfinder_", res_snps$GENE)

                        #fix sample names of res_snps for consistency
                        res_snps$name <- gsub("/.*/", "", res_snps$name)
                        res_snps$name <- gsub("_blastn_results.tsv", "", res_snps$name)

                        # appends a 1 to the final column of each row (used later by dcast)
                        rep(x = 1, times = nrow(res_snps)) -> res_snps$gene_present

                        res_snps <- as.data.table(res_snps)

                        #Cast the dataframe into a more usable format
                        res_snps2 <-
                                data.table::dcast(
                                        data = res_snps,
                                        formula = name ~ GENE,
                                        value.var = 'gene_present',
                                        drop = FALSE
                                )

                }

                if (ColV_Liu_data != "b") {
                        #Read in abricate data on resistance snps
                        colv <- read_delim(abricate_in,
                                           "\t",
                                           escape_double = FALSE,
                                           trim_ws = TRUE)

                        #Remove cases where there are multiple headers from concatenation of abricate reports
                        colv <- colv %>% filter(grepl("colv", DATABASE))

                        #Colname reassignment
                        colnames(colv)[c(1, 10:11)] <-
                                c("name", "perc_coverage", "perc_identity")
                        df_colnames <- colnames(colv)

                        #Convert percent coverage and identity to numeric type to allow filtering
                        colv$perc_coverage <- as.numeric(colv$perc_coverage)
                        colv$perc_identity <- as.numeric(colv$perc_identity)

                        #apply our filter to only allow genes which have a percent coverage of >=95 and a percent identity of >=90
                        colv <-
                                colv %>% filter(perc_coverage >= 90) %>% filter(perc_identity >= 95)

                        if(nrow(colv) > 0){

                                # appends a 1 to the final column of each row (used later by dcast)
                                rep(x = 1, times = nrow(colv)) -> colv$gene_present

                                # Removes .fasta* in column sample name
                                gsub(pattern = "\\.fasta.*",
                                     replacement = "",
                                     x = colv$name) ->
                                        colv$name

                                # appends a 1 to the final column of each row (used later by dcast)
                                rep(x = 1, times = nrow(colv)) -> colv$gene_present

                                #cast the data to generate a table showing which genes are present and which genes are absent
                                #i.e. make the list wide rather than long
                                simple_summary <- dcast(
                                        data = colv,
                                        name ~ GENE,
                                        value.var = 'gene_present',
                                        drop = FALSE
                                )

                                #create a new column for each group of genes and assign to each cell in this column the sum of the number of genes from each group present in a given sample
                                simple_summary <-
                                        simple_summary %>% mutate(grp1_cvaABC_cvi = cvaA + cvaB + cvaC + cvi)
                                simple_summary <-
                                        simple_summary %>% mutate(grp2_iroBCDEN = iroB + iroC + iroD + iroE + iroN)
                                simple_summary <-
                                        simple_summary %>% mutate(grp3_iucABCD_iutA = iucA + iucB + iucC + iucD + iutA)
                                simple_summary <-
                                        simple_summary %>% mutate(grp4_etsABC = etsA + etsB + etsC)
                                simple_summary <-
                                        simple_summary %>% mutate(grp5_ompT_hlyF = ompT + hlyF)
                                simple_summary <-
                                        simple_summary %>% mutate(grp6_sitABCD = sitA + sitB + sitC + sitD)

                                #Save the row names to a different object so we can later reassign them after editing the table
                                assembly_name <- simple_summary$name

                                #Take all rows and all columns except for the first column and reassign the dataframe "simple summary" as such
                                simple_summary <-
                                        simple_summary[1:nrow(simple_summary), 2:ncol(simple_summary)]

                                #Replace gene hits such that if any gene was detected more than once, or if more than one gene in a given group were detected, a corresponding gene/gene group is not counted twice
                                simple_summary[simple_summary > 1] <- 1

                                #reassign the Assembly_barcode column
                                simple_summary$name <- assembly_name

                                #change the column order so that Assembly_barcode comes first.
                                simple_summary <-
                                        simple_summary %>% select(name, everything())

                                #Add an extra column which sums the number of gene groups detected
                                simple_summary <-
                                        simple_summary %>% mutate(
                                                grp_sum = grp1_cvaABC_cvi + grp2_iroBCDEN + grp3_iucABCD_iutA + grp4_etsABC +
                                                        grp5_ompT_hlyF + grp6_sitABCD
                                        )

                                #If 3 or less gene groups were detected within a given sample, replace this value with No (ColV plasmid not considered present)
                                simple_summary$ColV <- gsub("1|2|3", "No", simple_summary$grp_sum)

                                #If 4 or more gene groups were detected within a given sample, replace this value with Yes (ColV plasmid considered present)
                                simple_summary$ColV <- gsub("4|5|6", "Yes", simple_summary$ColV)

                                simple_summary$ColV <- gsub("No", "0", simple_summary$ColV)
                                simple_summary$ColV <- gsub("Yes", "1", simple_summary$ColV)

                                #Replace all NAs with zeroes, as these strains did not carry and genes from the ColV abricate screen at all and instead come up as NA
                                #CHECK THIS
                                simple_summary[is.na(simple_summary)] <- 0

                                assign(paste(name, "colv", paste("N", 95, sep = ""), paste("L", 90, sep =""), sep = "."), simple_summary, envir=globalenv())
                                assign(paste(name, "colv_summary", sep = "."), colv, envir=globalenv())
                                ColV_binary <- simple_summary %>% select(name, ColV)
                        }else{
                                message("No ColV hits detected")

                                #Read in abricate data on resistance snps
                                colv <- read_delim(abricate_in,
                                                   "\t",
                                                   escape_double = FALSE,
                                                   trim_ws = TRUE)

                                #Remove cases where there are multiple headers from concatenation of abricate reports
                                colv <- colv %>% filter(grepl("colv", DATABASE))

                                #Remove cases where there are multiple headers from concatenation of abricate reports
                                colv <- colv %>% filter(SEQUENCE != "SEQUENCE")

                                #Colname reassignment
                                colnames(colv)[c(1, 10:11)] <-
                                        c("name", "perc_coverage", "perc_identity")

                                # Removes .fasta* in column sample name
                                gsub(pattern = "\\.fasta.*",
                                     replacement = "",
                                     x = colv$name) ->
                                        colv$name

                                ColV_binary <- cbind(unique(colv$name),
                                                     rep(x = 0,
                                                         times = length(unique(colv$name)))
                                )
                                ColV_binary <- as.data.frame(ColV_binary)

                                colnames(ColV_binary) <- c("name","ColV")

                        }

                }

                if (pMLST_data != "c") {
                        pMLST <- read_delim(pMLST_data,
                                            "\t", escape_double = FALSE, trim_ws = TRUE)

                        pMLST <- as.data.table(pMLST)

                        pMLST <- data.table::dcast(
                                data = pMLST,
                                name ~ pMLST_scheme,
                                value.var = "pMLST",
                                drop = FALSE,
                                fun.aggregate=function(x) paste(x, collapse = "/ ")
                        )
                        colnames(pMLST) <- gsub(" ","_",colnames(pMLST))
                }

                #adds the name of the database to the start of the gene name (for later sorting)
                df$GENE <- paste0(df$DATABASE, "_", df$GENE)

                # Assigns all hits meeting criteria of
                # X% Nucleotide match and Y% Length Match to variable filename.NX.LY.PASS
                # (tweak arguments 3 and 4 of blastlord to change the nucleotide and length criteria)
                df1 <-
                        subset.data.frame(df,
                                          df$perc_identity >= identity & df$perc_coverage >= length)
                assign(paste(
                        name,
                        paste("N", identity, sep = ""),
                        paste("L", length, sep = ""),
                        "PASS",
                        sep = "."
                ),
                df1,
                envir = globalenv())

                # Assigns all hits NOT meeting criteria of
                # X% Nucleotide match and Y% Length Match to variable filename.NX.LY.FAIL
                # (tweak arguments 3 and 4 of blastlord to change the nucleotide and length criteria)
                df2 <-
                        subset.data.frame(df,
                                          df$perc_identity < identity & df$perc_coverage < length)
                assign(paste(
                        name,
                        paste("N", identity, sep = ""),
                        paste("L", length, sep = ""),
                        "FAIL",
                        sep = "."
                ),
                df2,
                envir = globalenv())

                if (pMLST_data != "c") {
                        assign("pMLST", pMLST, envir = globalenv())
                }
                # Generates a simple summary table of genes (not including allele variants) from
                # df1 (PASS file) that contains hits that passed the set criteria

                #df1 <- as.data.table(df1)

                dcast(
                        data = df1,
                        name ~ GENE,
                        value.var = 'gene_present',
                        drop = FALSE
                ) -> df3
                if (pointfinder_data != "a") {
                        df3 <- left_join(df3, res_snps2)
                        df3[is.na(df3)] <- 0
                        message("Combining pointfinder data...")
                }
                if (ColV_Liu_data != "b") {
                        df3 <- left_join(df3, ColV_binary)
                        df3[is.na(df3)] <- 0
                        message("Combining ColV data...")
                }
                if (pMLST_data != "c") {
                        df3 <- left_join(df3, pMLST)
                        df3[is.na(df3)] <- 0
                        message("Combining pMLST data...")
                }
                assign(
                        paste(
                                name,
                                "_simple_summary_",
                                "N",
                                identity,
                                "L",
                                length,
                                sep = ""
                        ),
                        df3,
                        envir = globalenv()
                )

                # Generates a table showing co-occurence of all genes on a given SEQUENCE for each sample.
                df5 <- df1 %>%
                        group_by(name, SEQUENCE) %>%
                        summarise(same_scaff = paste(unique(GENE), collapse = " "))
                assign(
                        paste(name, "_co_occurence_", "N", identity, "L", length, sep = ""),
                        df5,
                        envir = globalenv()
                )

                if (writecsv == TRUE) {
                        message("Writing objects to csv file...")
                        write.csv(df1, paste(
                                output_directory,
                                "/",
                                paste(
                                        name,
                                        paste("N", identity, sep = ""),
                                        paste("L", length, sep = ""),
                                        "PASS",
                                        sep = "."
                                ),
                                ".csv",
                                sep = ""
                        ))
                        write.csv(df2, paste(
                                output_directory,
                                "/",
                                paste(
                                        name,
                                        paste("N", identity, sep = ""),
                                        paste("L", length, sep = ""),
                                        "FAIL",
                                        sep = "."
                                ),
                                ".csv",
                                sep = ""
                        ))
                        write.csv(df3, paste(
                                output_directory,
                                "/",
                                paste(
                                        name,
                                        "_simple_summary_",
                                        "N",
                                        identity,
                                        "L",
                                        length,
                                        sep = ""),
                                ".csv",
                                sep = ""),
                                row.names = FALSE)
                        write.csv(df5, paste(
                                output_directory,
                                "/",
                                paste(
                                        name,
                                        "_same_scaff_",
                                        "N",
                                        identity,
                                        "L",
                                        length,
                                        sep = ""
                                ),
                                ".csv",
                                sep = ""
                        ))
                        message("Writing complete; script finished.")
                }
                else {
                        message("Files not written to disk; script finished.")
                }
        }


args = commandArgs(trailingOnly=TRUE)
if (length(args)==0) {
  stop("At least one argument must be supplied", call.=FALSE)
}

abricate_in = args[1]
output_directory = args[2]
output = args[3]
identity = as.numeric(args[4])
length = as.numeric(args[5])
pointfinder_data = args[6]
pmlst_data = args[7]

abricateR(
    abricate_in = args[1],
    output = args[2],
    output_directory = args[3],
    identity = as.numeric(args[4]),
    length = as.numeric(args[5]),
    writecsv = TRUE,
    pointfinder_data = args[6],
    ColV_Liu_data = "b",
    pMLST_data = args[7])